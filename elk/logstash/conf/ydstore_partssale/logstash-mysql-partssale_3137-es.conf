# Sample Logstash configuration for creating a simple
# Beats -> Logstash -> Elasticsearch pipeline.

input {
  jdbc{
     type => "partssale_3137_qas"
	 #The path to our download jdbc driver
	 jdbc_connection_string => "jdbc:mysql://192.168.20.20:3307/ydqas?useConfigs=maxPerformance&characterEncoding=utf8"
	 jdbc_driver_library => "/usr/local/logstash/driver/mysql-connector-java-5.1.46.jar"
	 jdbc_driver_class => "com.mysql.jdbc.driver"
	 
	 #The user we wish to execute our statement as
	 jdbc_user => "ydqas"
	 jdbc_password => "ydqas"
	 
	 #last_run_metadata_path => "./logstash_last_run_display"
	 
	 #every 5 minutes execute
	 #schedule => "*/5 * * * *"
	 #schedule => "* * * * *"
	 #if clean_run set to true, sql_last_value is set to 19700101
	 clean_run => true 
	 last_run_metadata_path => "./logstash_jdbc_last_run"
	 #out query
	 parameters => {"ydstorepk" => 8796127065430}
	 #statement => "select * from sys_user where name = :name"
	 #statement => "select * from ydstore where createdTs > :sql_last_value"
     #statement => "select * from formalorder where createdTs > :sql_last_value"
	 statement => "SELECT p.pk AS pk, DATE_FORMAT(p.modifiedTS, '%Y-%m-%d %T.%f') AS modifiedts, DATE_FORMAT(p.createdTs, '%Y-%m-%d %T.%f') AS createdts, mps.modifiedts AS pricemodifiedts, mps.createdts AS pricecreatedts, pl.p_name AS name, p.p_code AS code, p.p_manucode AS manucode, p.p_baseunit AS baseunit, p.p_pricequantity AS pricequantity, p.p_approvalstatus AS approvalstatus, evp.code AS statuscode, mps.pricepk AS pricepk, mps.pricecode AS pricecode, mps.priceunit AS priceunit, mps.pricecondition AS pricecondition, mps.pricestartdate AS pricestartdate, mps.priceenddate AS priceenddate, mps.price AS price, :ydstorepk AS ydstorepk, GROUP_CONCAT(cp.sourcepk) AS categorylist, GROUP_CONCAT(vb.p_code) AS brandcodelist, GROUP_CONCAT(vbl.p_name) AS brandnamelist FROM parts p INNER JOIN (SELECT p_name, ITEMPK FROM partslp) pl ON pl.ITEMPK = p.PK INNER JOIN (SELECT sourcepk, targetpk FROM cat2prodrel) cp ON cp.targetpk = p.PK INNER JOIN (SELECT p_code, pk, p_brandtype FROM vehiclebrand) vb ON vb.PK = cp.sourcepk INNER JOIN (SELECT p_name, ITEMPK FROM vehiclebrandlp) vbl ON vb.PK = vbl.ITEMPK INNER JOIN (SELECT code, pk FROM enumerationvalues) evp ON evp.PK = p.p_approvalstatus LEFT JOIN (SELECT DISTINCT ps.PK AS pricepk, DATE_FORMAT(ps.modifiedTS, '%Y-%m-%d %T.%f') AS modifiedts, DATE_FORMAT(ps.createdTs, '%Y-%m-%d %T.%f') AS createdts, ps.p_code AS pricecode, ps.p_priceunit AS priceunit, ps.p_pricecondition AS pricecondition, ps.p_pricestartdate AS pricestartdate, ps.p_priceenddate AS priceenddate, ps.p_price AS price, ps.p_product AS productpk FROM partssale ps WHERE ps.p_ydstore = :ydstorepk) mps ON mps.productpk = p.PK GROUP BY p.pk,  p.modifiedTS,p.createdTs, mps.modifiedts, mps.createdts, pl.p_name, p.p_code, p.p_manucode, p.p_baseunit, p.p_pricequantity, p.p_approvalstatus, evp.code, mps.pricepk, mps.pricecode, mps.priceunit, mps.pricecondition, mps.pricestartdate, mps.priceenddate, mps.price "
	 use_column_value => true
	 tracking_column => "modifiedts"
	 
	 jdbc_paging_enabled => "true"
	 jdbc_page_size => "1000"
	 
	 jdbc_default_timezone =>"Asia/Shanghai"
  }
}

filter {
  ruby {
    code => "event.set('id',event.get('pk'))"
  }
}

output {
  if[type]=="partssale_3137_qas" {
      stdout { codec => rubydebug }
	  elasticsearch {
		#hosts => ["http://localhost:9200"]
		hosts => ["http://localhost:8250"]
		index => "partssale_3137_qas"
		document_id => "%{id}"
		doc_as_upsert => true
		#send data to es every 10 seconds
		#idle_flush_time => 10
		#user => "elastic"
		#password => "changeme"
		#action => "update"
		action => "index"
		manage_template=>true
		template_name=>"partssale_3137_qas"
		template_overwrite => true
        template => "/data/software/logstash/template/ydstore_partssale/template-ydstore-partssale.json"
	  }
  }
}
