# Sample Logstash configuration for creating a simple
# Beats -> Logstash -> Elasticsearch pipeline.

input {
	jdbc{
		type => "maintenance_test"
		#The path to our download jdbc driver
		#jdbc_connection_string => "jdbc:mysql://localhost:3306/hybris?useConfigs=maxPerformance&characterEncoding=utf8"
		#jdbc_connection_string => "jdbc:mysql://192.168.20.20:3307/hybris_db2?useConfigs=maxPerformance&characterEncoding=utf8"
		#jdbc_connection_string => "jdbc:mysql://172.19.65.159:3306/hybris_db2?useConfigs=maxPerformance&characterEncoding=utf8&useSSL=false"
		jdbc_connection_string => "jdbc:mysql://172.19.65.175:3306/hybris_db2?useConfigs=maxPerformance&characterEncoding=utf8&useSSL=false"
		jdbc_driver_library => "/root/data/software/logstash-6.7.0/lib/mysql-connector-java-5.1.46.jar"
		#jdbc_driver_library => "/usr/local/logstash/driver/mysql-connector-java-5.1.46.jar"
		#jdbc_driver_library => "/Users/lizhen/.m2/repository/mysql/mysql-connector-java/5.1.46/mysql-connector-java-5.1.46.jar"
		jdbc_driver_class => "com.mysql.jdbc.driver"

		#The user we wish to execute our statement as
		#jdbc_user => "ydqas"
		#jdbc_password => "ydqas"

		jdbc_user => "root"
		jdbc_password => "123456"

		#last_run_metadata_path => "./logstash_last_run_display"

		#every 5 minutes execute
		#schedule => "*/2 * * * *"
		schedule => "*/5 * * * *"
		#if clean_run set to true, sql_last_value is set to 19700101
		#clean_run => true
		last_run_metadata_path => "./last_run/logstash_jdbc_last_run_maintenance_test"
		record_last_run => true
		#out query
		#parameters => {"name" => "长沙大东家"}
		#statement => "select * from sys_user where name = :name"
		#statement => "select * from ydstore where createdTs > :sql_last_value"
		#statement => "select * from formalorder where createdTs > :sql_last_value"
		#statement => "SELECT m.PK AS pk, mp.modifiedTS as modifiedts, mp.createdTs as createdts, m.p_code as maintenancecode, m.p_manualcode AS manualcode,m.p_manualcodedescription as manualcodedescription, m.p_manualcategory as manualcategory,m.p_deleteflag as deleteflag, m.p_pricereferencematerial as pricereferencematerial, mp.p_code as pricecode,mp.p_price as price, mp.p_saleOrganization as saleorganization, mp.p_conditionValidStartDate as conditionvalidstartdate, mp.p_conditionvalidenddate as conditionvalidenddate, mp.p_conditioncurrency as conditioncurrency, mp.p_materialcode as materialcode,mp.p_ydstore as ydstorepk, mp.p_conditioncode as conditioncode, mp.p_conditiontype as conditiontype,mh.p_code as hourcode,mh.p_planmanualtime as planmanualtime, mh.p_manualtype as manualtype, mh.p_manualtargettimeunit as manualtargettimeunit,s.p_uid as storeuid  FROM maintenance m LEFT JOIN maintenancehour mh ON m.p_manualcategory = mh.p_manualcategory AND m.p_manualcode = mh.p_manualcode LEFT JOIN maintenanceprice mp ON m.p_pricereferencematerial = mp.p_materialcode AND mp.p_manualtype = mh.p_manualtype left join ydstore s on s.PK = mp.p_ydstore "
		#statement => "SELECT 0 as pkmod, mh.PK AS pk, m.pk as mpk, mp.modifiedTS as modifiedts, mp.createdTs as createdts, m.p_code as maintenancecode, m.p_manualcode AS manualcode,m.p_manualcodedescription as manualcodedescription, m.p_manualcategory as manualcategory,m.p_deleteflag as deleteflag, m.p_pricereferencematerial as pricereferencematerial, mp.p_code as pricecode,mp.p_price as price, mp.p_saleOrganization as saleorganization, mp.p_conditionValidStartDate as conditionvalidstartdate, mp.p_conditionvalidenddate as conditionvalidenddate, mp.p_conditioncurrency as conditioncurrency, mp.p_materialcode as materialcode,mp.p_ydstore as ydstorepk, mp.p_conditioncode as conditioncode, mp.p_conditiontype as conditiontype,mh.p_code as hourcode,mh.p_planmanualtime as planmanualtime, mh.p_manualtype as manualtype, mh.p_manualtargettimeunit as manualtargettimeunit,s.p_uid as storeuid  FROM maintenance m INNER JOIN maintenancehour mh ON m.p_manualcategory = mh.p_manualcategory AND m.p_manualcode = mh.p_manualcode LEFT JOIN maintenanceprice mp ON m.p_pricereferencematerial = mp.p_materialcode AND mp.p_manualtype = mh.p_manualtype left join ydstore s on s.PK = mp.p_ydstore "
		#statement => "SELECT mh.PK AS pk, m.PK as mpk, mp.modifiedTS as modifiedts, mp.createdTs as createdts, m.p_code as maintenancecode, m.p_manualcode AS manualcode,m.p_manualcodedescription as manualcodedescription, m.p_manualcategory as manualcategory,m.p_deleteflag as deleteflag, m.p_pricereferencematerial as pricereferencematerial, mp.p_code as pricecode,mp.p_price as price, mp.p_saleOrganization as saleorganization, mp.p_conditionValidStartDate as conditionvalidstartdate, mp.p_conditionvalidenddate as conditionvalidenddate, mp.p_conditioncurrency as conditioncurrency, mp.p_materialcode as materialcode,mp.p_ydstore as ydstorepk, mp.p_conditioncode as conditioncode, mp.p_conditiontype as conditiontype,mh.p_code as hourcode,mh.p_planmanualtime as planmanualtime, mh.p_manualtype as manualtype, mh.p_manualtargettimeunit as manualtargettimeunit,s.p_uid as storeuid  FROM maintenancehour mh INNER JOIN maintenance m ON m.p_manualcategory = mh.p_manualcategory AND m.p_manualcode = mh.p_manualcode LEFT JOIN maintenanceprice mp ON m.p_pricereferencematerial = mp.p_materialcode AND mp.p_manualtype = mh.p_manualtype left join ydstore s on s.PK = mp.p_ydstore where mod(mh.PK, 5) = 0 order by modifiedts desc"
		#statement => "select * from (SELECT mh.PK AS pk, m.PK as mpk, mh.modifiedTS as modifiedts, mh.createdTs as createdts, UNIX_TIMESTAMP(mh.modifiedTS) as modifiedmills , m.p_code as maintenancecode, m.p_manualcode AS manualcode,m.p_manualcodedescription as manualcodedescription, m.p_manualcategory as manualcategory, m.p_deleteflag as deleteflag, m.p_pricereferencematerial as pricereferencematerial, mp.p_code as pricecode,mp.p_price as price, mp.p_saleOrganization as saleorganization, mp.p_conditionValidStartDate as conditionvalidstartdate, mp.p_conditionvalidenddate as conditionvalidenddate, mp.p_conditioncurrency as conditioncurrency, mp.p_materialcode as materialcode,mp.p_ydstore as ydstorepk, mp.p_conditioncode as conditioncode, mp.p_conditiontype as conditiontype, mh.p_code as hourcode,mh.p_planmanualtime as planmanualtime, mh.p_manualtype as manualtype, mh.p_manualtargettimeunit as manualtargettimeunit, s.p_uid as storeuid  FROM maintenance m INNER JOIN maintenancehour mh ON m.p_manualcategory = mh.p_manualcategory AND m.p_manualcode = mh.p_manualcode LEFT JOIN maintenanceprice mp ON m.p_pricereferencematerial = mp.p_materialcode AND mp.p_manualtype = mh.p_manualtype left join ydstore s on s.PK = mp.p_ydstore where mod(mh.PK, 31) = 0 ) t order by t.modifiedmills desc "
		statement => "SELECT (:sql_last_value + 10000) as cursor, mh.PK AS pk, m.PK as mpk, mh.modifiedTS as modifiedts, mh.createdTs as createdts, UNIX_TIMESTAMP(mh.modifiedTS) as modifiedmills , m.p_code as maintenancecode, m.p_manualcode AS manualcode,m.p_manualcodedescription as manualcodedescription, m.p_manualcategory as manualcategory, m.p_deleteflag as deleteflag, m.p_pricereferencematerial as pricereferencematerial, mp.p_code as pricecode,mp.p_price as price, mp.p_saleOrganization as saleorganization, mp.p_conditionValidStartDate as conditionvalidstartdate, mp.p_conditionvalidenddate as conditionvalidenddate, mp.p_conditioncurrency as conditioncurrency, mp.p_materialcode as materialcode,mp.p_ydstore as ydstorepk, mp.p_conditioncode as conditioncode, mp.p_conditiontype as conditiontype, mh.p_code as hourcode,mh.p_planmanualtime as planmanualtime, mh.p_manualtype as manualtype, mh.p_manualtargettimeunit as manualtargettimeunit, s.p_uid as storeuid  FROM maintenance m INNER JOIN maintenancehour mh ON m.p_manualcategory = mh.p_manualcategory AND m.p_manualcode = mh.p_manualcode LEFT JOIN maintenanceprice mp ON m.p_pricereferencematerial = mp.p_materialcode AND mp.p_manualtype = mh.p_manualtype left join ydstore s on s.PK = mp.p_ydstore order by UNIX_TIMESTAMP(mh.modifiedTS) desc limit :sql_last_value offset 10000"
		use_column_value => true
		tracking_column => "cursor"
		#jdbc_paging_enabled => "true"
		#jdbc_page_size => "1000"

		jdbc_default_timezone =>"Asia/Shanghai"
	}
}

filter {
	ruby {
		code => "
		event.set('modifiedts', event.get('modifiedts').time.localtime('+08:00'))
		event.set('createdts', event.get('createdts').time.localtime('+08:00'))
		"
		#path => "/usr/local/logstash/template/template-ydstore.rb"
	}
}

output {
	if[type]=="maintenance_test" {
		stdout { codec => rubydebug }
		elasticsearch {
			#hosts => ["http://localhost:8250"]
			hosts => ["http://172.19.65.165:9200"]
			index => "%{type}"
			#document_id => "%{id}"
			doc_as_upsert => true
			#user => "elastic"
			#password => "changeme"
			action => "index"
			manage_template=>true
			template_name=>"maintenance_test"
			template_overwrite => true
			template => "/root/data/software/logstash/template/local/template-maintenance-test.json"
		}
	}
}